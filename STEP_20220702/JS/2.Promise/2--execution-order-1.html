<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      new Promise((resolve, reject) => {
        setTimeout(() => {
          console.log(1);
          resolve(2);
        });
      }).then((value) => console.log(value));
      console.log(3);

      // 1
      // 宏任务队列 [setTimeout]
      // 微任务队列 []
      // 同步任务 3
      // 结果：
      // - 先执行同步任务3，再清空微任务队列，然后执行一个宏任务队列中的宏任务
      // - 输出 3

      // 2
      // 宏任务队列 []
      // 微任务队列 2
      // 执行为任务队列为空，再执行 setTimeout，输出 1
      // - 输出 1

      // 3
      // 宏任务队列 []
      // 微任务队列 [2]
      // - 输出 2

      // 最终
      // 3 1 2

      // 分割线 -------------------------------------------------------------------
      // 分割线 -------------------------------------------------------------------
      // 分割线 -------------------------------------------------------------------
      // 分割线 -------------------------------------------------------------------
      // 分割线 -------------------------------------------------------------------

      // 拓展

      // 1
      // 常见的宏任务：setTimeout setInterval setImmediate requestAnimationFrame
      // 常见的微任务：promise process.nextTick MutationObserver

      // 2
      // 这里说的微任务 promise，指的是 promise.then  promise.catch promise.finally

      // 3
      // node 的事件

      // - 一共分为6个阶段
      //  - 1. timer -------------------------- 计时 和 执行到点的计时器
      //  - 2. pending callbacks -------------- 执行延迟到下一个循环迭代的 I/O 回调
      //  - 3. idea prepare ------------------- 系统的一些准备工作，仅系统内部使用
      //  - 4. poll --------------------------- 轮训
      //  - 5. check -------------------------- 执行 setImmediate 函数
      //  - 6. close callback ----------------- 关闭

      // - 具体
      // - timer节点：计时 和 执行到点的计时器
      // - pending callback
      // - idea prepare
      // - poll阶段
      //    - 1. 如果轮询队列不为空，就依次取出来执行，直到轮训队列为空 或者 达到系统的最大限制
      //    - 2. 如果轮询队列为空
      //       - 1. 如果之前设置过setImmediate函数：则立即进入下一个阶段 ---- check 阶段
      //       - 2. 如果之前没有设置过etImmediate函数：则会 ( 等待 )
      //            - 直到 ( 轮训队列有新添加的任务 )，则会重复以上步骤
      //            - 或者 ( 有到点的计时器 )，则也会立即进入下一个阶段 ------ check阶段
      // - check阶段：执行定时器
      // - close callback阶段：关闭一些回调函数，比如 socket.on()
    </script>
  </body>
</html>
