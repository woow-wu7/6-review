# 作用域 + 作用域链 + 执行上下文(对象) + 执行上下文栈

### (一) 单词

- execution 执行 n

### (二) 总结

- 形成的时机
  - 函数作用域：在 ( 函数声明时 ) 确定
  - 函数执行上下文对象：在 ( 函数调用时，并且在函数体执行前 ) 创建
- 静态/动态
  - 函数作用域：静态的，函数定义时确定，且不会在变化
  - 函数执行上下文对象：动态的，函数调用时创建，函数执行完后释放
- 联系
  - ( 执行上下文对象 ) 从属于 ( 作用域 )
  - 函数执行上下文对象 从属于 函数作用域
  - 全局执行上下文对象 从属于 全局作用域

### (三) 作用域

- 定义
  - 作用域指：( 变量和函数 ) 存在的范围
- 作用
  - 作用域的主要的作用就是：( 隔离变量 )，即不同作用域的变量相互隔离，不会产生( 变量污染 )
- 分类
  - 全局作用域
  - 函数作用域
  - 块级作用域
- 函数本身的作用域
  - 函数本身也是一个值，也有自己的作用域，函数本身的作用域是 ( 函数定义时所在的所用域，而不是函数调用时所在的作用域 )

### (四) 执行上下文 ( 对象 )

- 分类

  - 全局执行上下文
  - 函数执行上下文
  - eval

- 全局执行上下文

  - 在全局代码执行前，将 ( window ) 确定为 ( 全局执行上下文 )
  - 对全局数据进行预处理
    - 全局变量：-------------> 变量名提升，并赋值为 undefined，并作为 window 的属性
    - 全局函数：-------------> 函数名提升，并赋值为该函数，并作为 window 的属性
    - this：----------------> 将 this 赋值给 window

- 函数执行上下文

  - 在 ( 函数调用 ) ( 并且函数体执行前 ) 创建对应的 ( 函数执行上下文对象 )
  - 对局部数据进行预处理
    - 形参 ----------------> 将行参赋值为 ( 实参 )，并添加为该函数执行上下文对象的属性
    - arguments 对象 -------> 赋值，并添加为该函数执行上下文对象的属性
    - 局部变量 -------------> 变量名提升，并且赋值为 undefined，并作为该函数执行上下文对象的属性
    - 局部函数 -------------> 将整个函数提升到头部，并作为该函数执行上下文对象的属性
    - this ----------------> 将 this 赋值给调用该函数的 对象
  - !!!!!!!!!!!!!!!!! 优先级 !!!!!!!!!!!!!!!!!
    - 函数形参 > 函数声明 > 变量声明
    - 函数名已经存在，新的覆盖旧的
    - 变量名已经存在，直接跳过变量的声明
  - 例子如下
  - 案例 1

  ```
  function a(name, age) {
    console.log(name); // wang
    var name = 10;
    console.log(name); // 10
    console.log(age);  // undefined
  }
  a('wang')

  ---
  实际执行的代码如下：
  function a(name, age) {
    // 1. 变量提升：形参 > 函数声明 > 变量声明
    var name = 'wang' // 形参赋值实参
    var age = undefined // 未传实参，则将形参赋值为undefined
    // var name = undefined 变量提升，但是变量名已经存在，则直接略过变量的声明
    console.log(name) // 'wang'
    name = 10 // 从新赋值
    console.log(name) // 10
    console.log(age) // undefined
  }

  ---
  最终结果
  'wang' 10 undefined
  ```

  - 案例 2

  ```
  function a(name) {
    console.log(name); // function name() {.....}
    var name = 10;
    function name() { console.log('20') }; }
  a('wang')

  ---
  实际执行的代码如下：
  function a(name) {
    var name = 'wang'
    // var name = undefined 变量提升，但是变量名已经存在，直接略过变量的声明
    function name() { console.log('20')} // 函数提升，但是函数名已经存在，则新的覆盖旧的，即函数覆盖掉'wang'
    console.log(name) // 此处打印函数
    name = 10 // 从新赋值
  }

  ---
  最终结果
  function name() { console.log('20') };
  ```

- 总结
  - 每调用一次函数，就会产生一个函数执行上下文
  - 执行山下文就是一个 ( 对象 )
  - 执行上下文分为：全局执行上下文 函数执行上下文 eval

### (五) 执行上下文栈

- 定义
  - ( 全局代码 ) 执行前，js 引擎会创建一个 ( 栈 ) 来存储管理 ( 执行上下文栈 )
- 栈的特点
  - 后进先出，出口入口一样
  - 对比：队列是先进先出，入口出口不一样

### (6) 箭头函数中的 this

- 定义
  - 箭头函数中的 this，指的是 ( 该箭头函数定义时所在的作用域的 ) ( 上层作用域中的 this )
- 理解
  - 箭头函数中的 this：指代的是箭头函数定义时所在作用域 的 上层作用域中的 this
  - 1. 首先搞清楚有几种作用域：( 全局作用域 ) ( 函数作用域 ) ( 块级作用域 )
  - 2. 箭头函数的 this 指向 ( 一定是固定的 )
- 案例 1

```
var a = 1
const obj = {
  a: 11,
  b: () => console.log(a)
}

obj.b()
// 1
// 分析：箭头函数定义时所在的所用域是 ( 块级作用域 )，上层作用域中的this是window
```

- 案例 2

```
var A = {
  name: "A",
  sayHello: function () {
    var s = () => console.log(this.name);
    return s;
  },
};

var sayHello = A.sayHello(); // 不管外面如何调用，都不会影响箭头函数this的指向，和调用无关
sayHello();

// A
// 分析
// 箭头函数定义时的作用域是 ( 函数作用域 )，上层作用域是 ( 块级作用域 )，上层作用域中的this指向对象A，所以A.name
```
