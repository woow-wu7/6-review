# 继承

# (一) es5 的继承

### (1) 原型链继承

- 原理：
  - 1. 将 ( 子类的 prototype ) 指向 ( 父类的实例 )
  - 2. 修改了子类的 prototype 后，需要修改 ( 子类.prototype.constructor ) 的指向，重新指回 ( 子类 )，不然将指父类
- 缺点
  - 1. 不能实现多继承，即不能继承多个父类
  - 2. 生成子类时，不能向父类传参
  - 3. 在给子类的 prototype 上添加属性，需要在将 子类.prototype 指向父类的实例之后
  - 4. 多个子类共享父类.prototype 上的属性和方法，当是引用类型的数据时，修改回相互影响
- 测试
  - code-test/原型链继承.html

### (2) 借用构造函数继承 ( 经典继承 )

- 原理
  - 1. 通过 call(this) 方法将 ( 父类中的 this ) 绑定到 ( 子类的 this ) 上
  - 2. 并执行父类
- 优点
  - 1. 可以实现多继承，即多次调用不同的父类
  - 2. 生成子类实例时，可以向父类传参
  - 3. 属性和方法都生成在子类的实例上，修改不会相互影响
- 缺点
  - 属性和方法生成在子类实例上，造成资源浪费
- 测试
  - code-test/借用构造函数继承.html

### (3) 组合式继承 ( 借用构造函数继承 + 原型链条继承 )

- 优点
  - 就是两个的优点
- 缺点
  - 1. 父类被调用了两次：一次是借用构造函数继承 call 的方式调用，一次是 new 父类的方式调用
  - 2. 因为父类被调用了两次，所以在 ( 子类实例上 ) 和 ( 子类实例原型上，其实也是父类生成的实例上 ) 具有一些相同的属性和方法，造成浪费
- 测试
  - code-test/组合式继承.html

### (4) 寄生组合式继承

- 优点
  - 主要是为了解决组合式继承时两次两用父类有重复的属性的问题
- parasitic 是寄生的意思

# (二) es6 的继承

- class 有两条继承线
  - 是构造函数的语法糖，同时具有 ( **proto** ) 和 ( prototype ) 两条继承线
- 具体
  - 子类 的原型是 父类
  - ( 子类.prototype ) 的原型是 ( 父类.prototype )
  - 总结
    - `子类.__proto__ = 父类`
    - `子类.prototype.__proto__ = 父类.prototype`
- class
  - prototype
    - 1. 类中的 ( 属性和方法 ) 都是定义在 ( 类.prototype ) 上的
    - 2. ClassA.prototype.constructor = classA 类的 prototype 上的 constructor 指向类本身
    - 3. classA.prototype 上的所有属性和方法都是 ( 不可枚举的 )
  - 静态方法 和 原型方法 和 静态属性
    - 定义
      - 静态方法：定义在类中，在方法前加上 ( static ) 关键字定义的方法是 ( 静态方法 )，( this 指向类 )
      - 原型方法：在类中定义的方法是 ( 实例方法 )
      - 静态属性：静态属性只能在 ( 类上定义 )，不能在 ( 类中定义 )
    - 区别：
      - 静态方法：
        - 不能被 ( 实例 ) 所继承，只能通过 ( 类本身来调用 )
        - 能被 ( 子类 ) 所继承
        - 总结：类的 ( 静态方法 ) ( 不能被实例所继承 ) 但是 ( 能被子类所继承 )
      - 原型方法：能被 ( 实例 ) 所继承，可以通过 ( 实例来调用 )
  - super
    - super 可以作为 ( 函数 ) 也可以作为 ( 对象 )
    - super 函数
      - ( super 作为函数 ) 时，( 只能用在构造函数中 ) 表示的是 ( 父类的构造函数 )
    - super 对象
      - 1. super 作为对象，在 ( 普通方法中 )，指的是 ( 父类的原型 )，( this 指向子类的实例 )
      - 2. super 作为对象，在 ( 静态方法中 )，指的是 ( 父类 )，( this 指向子类 )
  - 注意点
    - 类中，默认是使用严格模式
    - 类中，不存在变量提升
    - 静态方法可以和非静态方法 重名

# (三) 总结

- 1. 所有的 ( 函数 )，都是 ( Function 构造函数 ) 的实例
- 2. 所有 ( 函数.prototype ) 都是 ( Object 构造函数 ) 的实例
- 注意点
  - Function 的 ( 隐式原型 ) 和 ( 显示原型 ) 都是 ( Function.prototype )
  - Function.prototype ---- **proto** ----> Object.prototype
