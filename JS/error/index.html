<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <SCript>
    // Error

    // const error = new Error('message')
    // const {message, name, stack} = error

    // console.log('error=>', error)
    // console.log(`message=>`, message)
    // console.log(`name=>`, name)
    // console.log(`stack=>`, stack)


    // var a = 1;
    // var obj = {
    //   a: 2,
    //   prop: {
    //     a: 3,
    //     getA: () => this.a
    //   },
    // }
    // const res = obj.prop.getA
    // console.log(obj.prop.getA())
    // console.log(res())

    // error对象 + 6中派生对象 + 自定义错误对象 = 8种错误对象
    // const error = new Error('error')
    // const syntaxError = new SyntaxError('syntaxError')
    // const referenceError = new ReferenceError('referenceError')
    // const rangeError = new RangeError('rangeError')
    // const typeError = new TypeError('typeError')
    // const uriError = new URIError('uriError')
    // const evalError = new EvalError('evalError')
  </SCript>
  <script>
    // try {
    //   throw new Error('抛出错误')
    //   console.log('此行不会执行');
    // } finally {
    //   console.log('虽然try中抛出了错误，但是finally代码块的代码还是会执行，只有try代码块中的代码执行完毕后，整个程序才会因为发生错误而终止执行')
    // }
    // console.log('此行也不会执行')

    // function idle() {
    //   try {
    //     console.log('1');
    //     return '3';
    //   } finally {
    //     console.log("2");
    //   }
    // }
    // const res = idle()
    // console.log(res)
    // 123
  </script>
  <script>
    function f() {
      try {
        console.log(0);
        throw 'bug';
      } catch (e) {
        console.log(1);
        return true; // 这句原本会延迟到 finally 代码块结束再执行，！！！！！因为需要在finally执行后才会返回值
        console.log(2); // 不会运行
      } finally {
        console.log(3);
        return false; // 这句会覆盖掉前面那句 return，！！！！！return false，后面的语句肯定不会再执行
        console.log(4); // 不会运行
      }

      console.log(5); // 不会运行，！！！！！因为finally中的return会作为整个程序的返回值，后面的所有语句都不会执行，这里是 4 5 不会再执行
    }

    var result = f();
    // 0
    // 1
    // 3
    result
    // false
  </script>
</body>

</html>